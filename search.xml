<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java多线程学习</title>
      <link href="2021/06/19/java-duo-xian-cheng-xue-xi/"/>
      <url>2021/06/19/java-duo-xian-cheng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><p>【狂神】Java多线程</p><hr><h2 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1. 线程简介"></a>1. 线程简介</h2><h3 id="1-1-任务，进程，线程，多线程"><a href="#1-1-任务，进程，线程，多线程" class="headerlink" title="1.1 任务，进程，线程，多线程"></a>1.1 任务，进程，线程，多线程</h3><h4 id="1-1-1-Process与Thread"><a href="#1-1-1-Process与Thread" class="headerlink" title="1.1.1 Process与Thread"></a>1.1.1 Process与Thread</h4><ul><li><p>Process与Thread</p><ul><li><p>说起进程，就不得不说下<strong>程序</strong>。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</p></li><li><p>而<strong>进程</strong>则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位</p></li><li><p>通常在一个进程中可以包含若干个<strong>线程</strong>，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的的单位。</p><blockquote><p>  <strong>注意</strong>：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局</p></blockquote></li></ul></li></ul><h4 id="1-1-2-本章核心概念"><a href="#1-1-2-本章核心概念" class="headerlink" title="1.1.2 本章核心概念"></a>1.1.2 本章核心概念</h4><ul><li>线程就是独立的执行路径；</li><li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程； </li><li>main（）称之为主线程，为系统的入口，用于执行整个程序；</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制</li><li>线程会带来额外的开销，如cpu调度时间，并发控制开销。</li><li>每个线程在自己的<strong>工作内存</strong>交互，内存控制不当会造成数据不一致</li></ul><h2 id="2-线程实现（重点）"><a href="#2-线程实现（重点）" class="headerlink" title="2. 线程实现（重点）"></a>2. 线程实现（重点）</h2><h3 id="2-1-线程创建"><a href="#2-1-线程创建" class="headerlink" title="2.1 线程创建"></a>2.1 线程创建</h3><p>Thread、 Runnable、 Callable</p><hr><h4 id="2-1-1-三种创建方式"><a href="#2-1-1-三种创建方式" class="headerlink" title="2.1.1 三种创建方式"></a>2.1.1 三种创建方式</h4><ol><li>Thread   ————&gt;继承 Thread类（重点）</li><li> Runnable【重点】  ————&gt;实现 Runnable接口（重点）</li><li> Callable【较难】 ————&gt;实现 Callable接口（了解）</li></ol><h4 id="2-1-2-方式1：继承Thread类"><a href="#2-1-2-方式1：继承Thread类" class="headerlink" title="2.1.2 方式1：继承Thread类"></a>2.1.2 方式1：继承Thread类</h4><ol><li>创建步骤：<ol><li> 自定义线程类继承 Thread类</li><li> 重写run() 方法，编写线程执行体</li><li> 创建线程对象，调用 start() 方法启动线程</li></ol> <strong>注</strong>：线程不一定立即执行，<strong>CPU</strong>安排调度</li></ol><ol start="2"><li><p>网络下载案例</p><ol><li><p>创建下载器（类），在此类中创建下载方法，</p><p><code>FileUtils.copyURLToFile(new URL(str),new File(name)); // common-io的包中</code></p><p>并且捕获异常。</p></li><li><p> 实现一个线程类，将自己的类  extends Thread，并且重写run()，重写构造器。</p></li><li><p> 通过start()方法来启动线程</p></li></ol></li></ol><h4 id="2-1-3-方式2：实现Runnable（推荐使用）"><a href="#2-1-3-方式2：实现Runnable（推荐使用）" class="headerlink" title="2.1.3 方式2：实现Runnable（推荐使用）"></a>2.1.3 方式2：实现Runnable（推荐<em>使用</em>）</h4><ol><li>实现步骤：<ol><li>定义 MyRunnable类实现 Runnable接囗</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用 start()方法启动线程（ MyRunnable类并没有start(),只能通过Thread()对象来调用start(),如：<code> new Thread(myRunnable).start();</code>）</li></ol></li><li><strong>小结</strong>：<ol><li>继承Thread类<ul><li>子类继承 Thread类具备多线程能力</li><li>启动线程：子类对象 start()</li><li><code>不建议使用</code>：<code>无法</code><strong>避免OOP单继承局限性</strong>，原因：假如你写一个类C，但这个类C已经继承了一个类A，此时，你又想让C实现多线程。用继承Thread类的方式不行了。</li></ul></li><li>实现Runnable接口<ul><li>实现接口 Runnable具有多线程能力</li><li>启动线程：传入目标对象+ Thread对象 start()</li><li><code>推荐使用</code>：<strong>避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</strong></li></ul></li></ol></li></ol><h4 id="2-1-4-方式3：实现Callable接口（了解即可）"><a href="#2-1-4-方式3：实现Callable接口（了解即可）" class="headerlink" title="2.1.4 方式3：实现Callable接口（了解即可）"></a>2.1.4 方式3：实现Callable接口（了解即可）</h4><ol><li>实现步骤<ol><li>实现 Callable接口,需要返回值类型</li><li>重写call方法,需要抛出异常</li><li>创建目标对象</li><li><strong>创建执行服务</strong>: ExecutorService ser= Executors. newFixedThreadPool(1);</li><li><strong>提交执行</strong>: Future&lt; Boolean&gt; result1= ser. submit(t1);//t1为实现了callable接口的类的对象</li><li><strong>获取结果</strong>: boolean r1= result1. get();</li><li><strong>关闭服务</strong>: ser. shutdownNow();</li></ol></li><li>与Runnable的比较：也就是上面4-7步骤不同</li><li>callable的好处：<ol><li>可以定义返回值</li><li>可以抛出异常</li><li>缺点：比较复杂，只要记住固定使用的步骤</li></ol></li></ol><h3 id="2-2-初识并发"><a href="#2-2-初识并发" class="headerlink" title="2.2 初识并发"></a>2.2 初识并发</h3><h4 id="2-2-1-买火车票例子"><a href="#2-2-1-买火车票例子" class="headerlink" title="2.2.1 买火车票例子"></a>2.2.1 买火车票例子</h4><ol><li><p>多个线程同时操作同一个对象</p></li><li><p>买火车票的例子</p></li><li><p>创建一个对象，使用 <code>new Thread(对象名，String).start();</code>来启动线程</p><p>注：<strong>发现问题</strong>：多个线程操作同一个资源的情况下，<strong>线程不安全</strong>，数据紊乱。</p></li></ol><h4 id="2-2-2-龟兔赛跑案例（迷迷糊糊，初识案例）"><a href="#2-2-2-龟兔赛跑案例（迷迷糊糊，初识案例）" class="headerlink" title="2.2.2 龟兔赛跑案例（迷迷糊糊，初识案例）"></a>2.2.2 龟兔赛跑案例（<del>迷迷糊糊</del>，初识案例）</h4><ol><li>规则<ol><li>首先来个赛道距离，然后要离终点越来越近</li><li>判断比赛是否结束</li><li>打印出胜利者</li><li>龟兔赛跑开始</li><li>故事中是乌龟嬴的，兔子需要睡觉，所以我们来模拟兔子睡觉</li><li>终于，乌龟赢得比赛</li></ol></li><li>实践：<ol><li>imlements Thread，override run()</li><li>在run()方法中输出”谁跑了第“ +i+ “步”</li><li>写一个判断是否比赛结束的方法gameOver()，在里面是否有winner或者step &gt;= 100，那么获取winner的名字</li><li>在run()方法中判断比赛是否结束，结束则break，否则继续执行</li><li>创建main()方法，新建一个线程对象，通过传入此对象，和不同的对象名字，分别调用new Thread(对象，String).start();</li><li>在run()方法中添加模拟兔子睡觉的程序。</li></ol></li></ol><h4 id="2-2-3-静态代理"><a href="#2-2-3-静态代理" class="headerlink" title="2.2.3 静态代理"></a>2.2.3 静态代理</h4><ol><li>静态代理模式总结：<br>真实对象和代理对象都要实现同一个接口<br>代理对象要代理真实角色</li><li>好处：<br>代理对象可以做很多真实对象做不了的事情<br>真实对象专注做自己的事情</li></ol><h4 id="2-2-4-lambda表达式"><a href="#2-2-4-lambda表达式" class="headerlink" title="2.2.4 lambda表达式"></a>2.2.4 lambda表达式</h4><ol><li><p>概述</p><p> ◆A希腊字母表中排序第十一位的字母，英语名称为Lambda<br> ◆避免匿名内部类定义过多<br> ◆其实质属于函数式编程的概念<br> （params）-&gt;expression[表达式]<br> &nbsp;&nbsp;&nbsp;&nbsp;（params）-&gt;statement[语句]<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（params）-&gt;{statements}<br> a-&gt;System.out.println（”i like lambda–&gt;”+a）；</p><p> 示例：new Thread(()&gt;System.out.println(“多线程学习….”)).start();</p></li></ol><p>◆为什么要使用lambda表达式<br>&nbsp;&nbsp;&nbsp;&nbsp;◆避免匿名内部类定义过多<br>&nbsp;&nbsp;&nbsp;&nbsp;◆可以让你的代码看起来很简洁<br>&nbsp;&nbsp;&nbsp;&nbsp;◆去掉了一堆没有意义的代码，只留下核心的逻辑。</p><p>◆也许你会说，我看了Lambda表达式，不但不觉得简洁，反而觉得更乱，看不懂了。那是因为我们还没有习惯，用的多了，看习惯了，就好了。</p><p>◆理解Functional Interface（函数式接口）是学习Java8 lambda表达式的关键所在。</p><p>◆函数式接口的定义：<br>&nbsp;&nbsp;&nbsp;&nbsp;◆任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;◆对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p><ol start="2"><li><p>流程</p><ol><li>定义函数式接口</li><li>实现类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li><li>lambda表达式</li></ol></li><li><p>总结：<br> &nbsp;&nbsp;&nbsp;&nbsp;//lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码染包裹。<br> &nbsp;&nbsp;&nbsp;&nbsp;//前提是接口为函数式接口<br> &nbsp;&nbsp;&nbsp;&nbsp;//多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号<br> &nbsp;&nbsp;&nbsp;&nbsp;//Runable接口就是一个很好的例子，它是函数式接口</p></li></ol><h2 id="3-线程状态"><a href="#3-线程状态" class="headerlink" title="3. 线程状态"></a>3. 线程状态</h2><h3 id="3-1线程状态"><a href="#3-1线程状态" class="headerlink" title="3.1线程状态"></a>3.1线程状态</h3><p><img src="/2021/06/19/java-duo-xian-cheng-xue-xi/1%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="1线程状态"></p><h4 id="3-1-1-停止线程"><a href="#3-1-1-停止线程" class="headerlink" title="3.1.1 停止线程"></a>3.1.1 停止线程</h4><p>◆不推荐使用JDK提供的stop（）、destroy（）方法。【已废弃】<br>◆推荐线程自己停止下来<br>◆建议使用一个标志位进行终止变量当flag=false，则终止线程运行。</p><h4 id="3-1-2-线程休眠"><a href="#3-1-2-线程休眠" class="headerlink" title="3.1.2 线程休眠"></a>3.1.2 线程休眠</h4><p>◆sleep（时间）指定当前线程阻塞的毫秒数；<br>◆sleep存在异常Interrupte  dException；<br>◆sleep时间达到后线程进入就绪状态；<br>◆sleep可以模拟网络延时，倒计时等。<br>◆每一个对象都有一个锁，<strong>sleep</strong>不会释放锁；</p><h4 id="3-1-3-线程礼让（yield）"><a href="#3-1-3-线程礼让（yield）" class="headerlink" title="3.1.3 线程礼让（yield）"></a>3.1.3 线程礼让（yield）</h4><p>◆礼让线程，让当前正在执行的线程暂停，但不阻塞<br>◆将线程从运行状态转为就绪状态<br>◆<strong>让cpu重新调度，礼让不一定成功！看CPU心情</strong></p><h4 id="3-1-4-Join"><a href="#3-1-4-Join" class="headerlink" title="3.1.4 Join"></a>3.1.4 Join</h4><p>◆Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p><p>◆可以想象成插队</p><h4 id="3-1-5-线程状态观测"><a href="#3-1-5-线程状态观测" class="headerlink" title="3.1.5 线程状态观测"></a>3.1.5 线程状态观测</h4><p>◆Thread.State</p><p>&nbsp;&nbsp;&nbsp;&nbsp;线程状态。线程可以处于以下状态之一：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·NEW  尚未启动的线程处于此状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·RUNNABLE  在Java虚拟机中执行的线程处于此状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·BLOCKED  被阻塞等待监视器锁定的线程处于此状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·WAITING  正在等待另一个线程执行特定动作的线程处于此状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·TIED_WAITING  正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·TERMINATED  已退出的线程处于此状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：线程只能启动一次。</p><h4 id="3-1-6-线程优先级"><a href="#3-1-6-线程优先级" class="headerlink" title="3.1.6 线程优先级"></a>3.1.6 线程优先级</h4><p>◆Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p><p>◆线程的优先级用数字表示，范围从1~10.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆Thread.MIN_PRIORITY=1；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆Thread.MAX_PRIORITY=10；  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆Thread.NORM_PRIORITY=5；</p><p>◆使用以下方式改变或获取优先级<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆getPriority（）.setPriority（int xxx）</p><p>注意：先设置优先级，再启动</p><h4 id="3-1-7-守护-daemon-线程"><a href="#3-1-7-守护-daemon-线程" class="headerlink" title="3.1.7 守护(daemon)线程"></a>3.1.7 守护(daemon)线程</h4><p>◆线程分为<strong>用户线程</strong>和<strong>守护线程</strong><br>◆虚拟机必须确保用户线程执行完毕<br>◆虚拟机不用等待守护线程执行完毕<br>◆如，后台记录操作日志，监控内存，垃圾回收等待.</p><h2 id="4-线程同步（重点）"><a href="#4-线程同步（重点）" class="headerlink" title="4. 线程同步（重点）"></a>4. 线程同步（重点）</h2><h4 id="4-1-1-并发"><a href="#4-1-1-并发" class="headerlink" title="4.1.1 并发"></a>4.1.1 并发</h4><p>◆并发：同一个对象被多个线程同时操作</p><p>◆处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步.线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个<strong>对象的等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用</p><p>线程同步：</p><p>◆由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入**锁机制synchronized **（是隐式锁），当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可.存在以下问题：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆一个线程持有锁会导致其他所有需要此锁的线程挂起；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题.</p><h4 id="4-1-2-同步方法"><a href="#4-1-2-同步方法" class="headerlink" title="4.1.2 同步方法"></a>4.1.2 同步方法</h4><p>◆由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized 关键字，它包括两种用法：synchronized 方法和synchronized块.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同步方法：public synchronized void method(int args){}<br>◆synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺陷：若将一个大的方法申明为synchronized将会影响效率</p><p>弊端：◆方法里面需要修改的内容才需要锁，锁的太多，浪费资源</p><p>同步块：</p><p>◆同步块：synchronized<strong>（Obj）{}</strong><br>◆<strong>Obj</strong>称之为<strong>同步监视器</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆Obj可以是任何对象，但是推荐使用共享资源作为同步监视器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class[反射中讲解]<br>◆同步监视器的执行过程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.第一个线程访问，锁定同步监视器，执行其中代码.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.第二个线程访问，发现同步监视器被锁定，无法访问.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.第一个线程访问完毕，解锁同步监视器.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问</p><h4 id="4-1-3-死锁"><a href="#4-1-3-死锁" class="headerlink" title="4.1.3 死锁"></a>4.1.3 死锁</h4><p>◆多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形.某一个同步块同时拥有“<strong>两个以上对象的锁</strong>”时，就可能会发生“死锁”的问题.</p><p>◆产生死锁的四个必要条件：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.互斥条件：一个资源每次只能被一个进程使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><h4 id="4-1-4-Lock-锁"><a href="#4-1-4-Lock-锁" class="headerlink" title="4.1.4 Lock(锁)"></a>4.1.4 Lock(锁)</h4><p>◆从JDK5.0开始，Java提供了更强大的线程同步机制——通过<strong>显式定义</strong>同步锁对象来实现同步。同步锁使用Lock对象充当<br>◆java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。<br>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象<br>◆ReentrantLock(<strong>可重入锁</strong>)类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p><h4 id="4-1-5-synchronized与lock的区别"><a href="#4-1-5-synchronized与lock的区别" class="headerlink" title="4.1.5 synchronized与lock的区别"></a>4.1.5 synchronized与lock的区别</h4><p>◆Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放<br>◆Lock只有代码块锁，synchronized有代码块锁和方法锁<br>◆使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）<br>◆优先使用顺序：<br>◆Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法（在方法体之外）</p><h2 id="5-线程通信问题"><a href="#5-线程通信问题" class="headerlink" title="5. 线程通信问题"></a>5. 线程通信问题</h2><h4 id="5-1-生产者消费者问题"><a href="#5-1-生产者消费者问题" class="headerlink" title="5.1 生产者消费者问题"></a>5.1 生产者消费者问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;1. 管程法：synchronized只能解决线程同步问题，无法解决线程通信问题。需要使用notify()，和wait()等方法来实现通行<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 信号灯法：使用一个标志位，来判断是notify()还是wait()。</p><h4 id="5-2-线程池"><a href="#5-2-线程池" class="headerlink" title="5.2 线程池"></a>5.2 线程池</h4><ol><li>介绍</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。<br>   可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆好处：<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆提高响应速度（减少了创建新线程的时间）<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆便于线程管理（…）<br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆corePoolSize：核心池的大小<br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆maximumPoolSize：最大线程数<br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆keepAlive Time：线程没有任务时最多保持多长时间后会终止</p><ol start="2"><li>使用方法：</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆JDK5.0起提供了线程池相关APl:ExecutorService 和Executors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆void execute（Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆<t> Future<t> submit（Callable<t>task）：执行任务，有返回值，一般又来执行Callable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆void shutdown（）：关闭连接池<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</t></t></t></p><h2 id="6-高级主题"><a href="#6-高级主题" class="headerlink" title="6. 高级主题"></a>6. 高级主题</h2>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="2021/03/04/java-ji-he-kuang-jia/"/>
      <url>2021/03/04/java-ji-he-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="1-集合的概念"><a href="#1-集合的概念" class="headerlink" title="1.集合的概念"></a>1.集合的概念</h2><h3 id="1-1什么是集合"><a href="#1-1什么是集合" class="headerlink" title="1.1什么是集合"></a>1.1什么是集合</h3><ul><li><p>概念:对象的容器,定义了对多个对象进行操作的常用方法.可实现数组的功能.</p></li><li><p>和数组区别:</p><ul><li>(1)数组长度固定,集合长度不固定</li><li>(2)数组可以存储基本类型和引用类型,集合只能存储引用类型</li></ul></li><li><p>位置：java.util.*;</p></li></ul><h2 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2.Collection接口"></a>2.Collection接口</h2><h3 id="2-1Collection体系集合"><a href="#2-1Collection体系集合" class="headerlink" title="2.1Collection体系集合"></a>2.1Collection体系集合</h3><p><img src="/2021/03/04/java-ji-he-kuang-jia/1Collection%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88.jpg" alt="1Collection体系集合"></p><ul><li>Collection：该体系结构的根接口,代表一组对象,称为”集合”.</li><li>List接口的特点: 有序、有下标、元素可重复</li><li>Set接口的特点：无序、无下标、元素不能重复</li></ul><h3 id="2-2Collection父接口"><a href="#2-2Collection父接口" class="headerlink" title="2.2Collection父接口"></a>2.2Collection父接口</h3><ol><li><p>特点：代表一组任意类型的对象,无序、无下标、不能重复（JDK API说一些有序，一些无序；一些可以重复，一些不可以重复）</p></li><li><p>方法：</p><ul><li>boolean add( Object obj) //添加一个对象.</li><li>boolean addAll(Collection c) //将一个集合中的所有对象添加到此集合中.</li><li>void clear() //清空此集合中的所有对象.</li><li>boolean contains( Object o)   //检查此集合中是否包含o对象</li><li>boolean equals( Object o) //比较此集合是否与指定对象相等.</li><li>boolean isEmpty() //判断此集合是否为空</li><li>boolean remove( Object o) //在此集合中移除o对象</li><li>int size() //返回此集合中的元素个数.</li><li>0bject[] toArray() //将此集合转换成数组.</li><li>Iterator<e>  <strong>iterator()</strong> //返回在此 collection的元素上进行迭代的迭代器（返回的是一个<strong>接口</strong>）.</e></li></ul></li></ol><hr><ol start="3"><li><p>Collection接口的使用1（保存<strong>字符串</strong>）</p><ol><li><p>添加元素</p></li><li><p>删除元素</p></li><li><p>遍历元素【<strong>重点</strong>】</p><ol><li><p>增强for循环</p></li><li><p>使用迭代器（迭代器专门用来遍历集合的一种方式）</p><ul><li><p>hasNext();有没有下一个元素,</p></li><li><p>next();获取下一个元素</p></li><li><p>remove();删除当前元素</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Iterator iterator = collection.iterator();while (iterator.hasNext()){&nbsp;&nbsp;&nbsp;     Object next = iterator.next();&nbsp;&nbsp;&nbsp;    System.out.println(next);&nbsp;&nbsp;&nbsp; //collection.remove(next);             //不能删除的当前要使用的，会出现ConcurrentModificationException(并发修改异常)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          //在迭代过程中不能用collection其他方法改变集合的元素的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;iterator.remove();//可以用迭代器（Iterator.remove()方法）中的方法来删除元素}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol></li><li><p>判断</p><ul><li>判断包含元素</li><li>判断是否为空</li></ul></li></ol></li></ol><hr><ol start="4"><li><p>Collection接口的使用2（保存<strong>对象</strong>）</p><ol><li>添加数据</li><li>删除数据</li><li>遍历数据<ol><li>增强for</li><li>迭代器Iterator</li></ol></li><li>判断</li></ol></li></ol><h2 id="3-List接口与实现"><a href="#3-List接口与实现" class="headerlink" title="3.List接口与实现"></a>3.List接口与实现</h2><h4 id="3-1List子接口"><a href="#3-1List子接口" class="headerlink" title="3.1List子接口"></a>3.1List子接口</h4><ol><li><p>特点：有序、有下标、元素可以重复。</p></li><li><p>方法：</p><ul><li>void add（ int index, Object o）//在 index位置插入对象o。</li><li>boolean addAll（ int index, Collection c）//将一个集合中的元素添加到此集合中的index位置。</li><li>Object get（ int index）//返回集合中指定位置的元素。</li><li>List subList（ int fromIndex, int toIndex）//返回 fromIndex和 toIndex之间的集合元素</li></ul></li></ol><ol start="3"><li><p>List子接口的使用1（添加<strong>字符串</strong>）</p><ol><li><p>添加数据</p><ul><li>按照元素<strong>内容</strong>添加</li><li>按照<strong>下标</strong>添加</li></ul></li><li><p>删除数据</p><ul><li>按照元素<strong>内容</strong>删除</li><li>按照<strong>下标</strong>删除</li></ul></li><li><p>遍历数据</p><ol><li>for循环</li><li>增强for</li><li>两种迭代器<br> 3.1 迭代器Iterator<br> 3.2 列表迭代器ListIterator    <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====3.1列表迭代器ListIterator从前往后====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ListIterator</span>  listIterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span>listIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====3.2列表迭代器ListIterator从前往后====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">previousIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span>listIterator<span class="token punctuation">.</span><span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>判断 </p></li><li><p>获取位置</p><ul><li>通过下标获取</li></ul></li></ol><hr></li><li><p>List子接口的使用2（添加<strong>数字</strong>）</p><ol><li><p>添加数字数据</p></li><li><p>删除数字数据</p><ol><li><p>转为object类型</p><p> <code>list.remove((Object) 20);</code></p></li><li><p>new Integer(20) ; 此处能够用这个方式，是因为整数缓冲的原</p><p>  <code>list.remove(new Integer(20));</code></p></li></ol></li><li><p>补充subList(); 返回子集合，含头不含尾</p></li></ol></li></ol><h3 id="3-2-List实现类"><a href="#3-2-List实现类" class="headerlink" title="3.2 List实现类"></a>3.2 List实现类</h3><h4 id="3-2-1-三种实现类"><a href="#3-2-1-三种实现类" class="headerlink" title="3.2.1 三种实现类"></a>3.2.1 三种实现类</h4><ol><li><p>ArrayList【<strong>重点</strong>】：</p><ul><li><p><strong>数组</strong>结构实现，需要开辟<strong>连续空间</strong>，查询快、增删慢； </p></li><li><p>JDK1.2版本，运行效率快、线程不安全。</p></li></ul></li><li><p>Vector:</p><ul><li><strong>数组</strong>结构实现，査询快、增删慢； </li><li>JDK1.0版本，运行效率慢、线程安全。</li></ul></li><li><p>LinkedList:</p><ul><li><strong>链表</strong>（双向链表）结构实现，<strong>不</strong>需要开辟<strong>连续空间</strong>，增删快，查询慢。</li></ul></li></ol><h4 id="3-2-2-ArrayList的使用"><a href="#3-2-2-ArrayList的使用" class="headerlink" title="3.2.2 ArrayList的使用"></a>3.2.2 ArrayList的使用</h4><ol><li><p>添加元素</p></li><li><p>删除元素</p><p><code>arrayList.remove(new Student("刘德华",20));//删不掉，原因在equals方法，需要重写</code></p></li><li><p>遍历元素【<strong>重点</strong>】</p><ol><li>for循环</li><li>增强for循环</li><li>两种迭代器<ol><li>迭代器Iterator</li><li>列表迭代器ListIterator（也有正序、逆序两种）</li></ol></li></ol></li><li><p>判断</p></li><li><p>查找</p></li></ol><h4 id="3-2-3ArrayList源码分析"><a href="#3-2-3ArrayList源码分析" class="headerlink" title="3.2.3ArrayList源码分析"></a>3.2.3ArrayList源码分析</h4><ul><li><p>源码分析：</p><ul><li>DEFAULT_ CAPACITY=10；默认容量</li><li>注意：如果没有向集合中添加任何元素时，容量0，添加一个元素之后容量10</li><li>每次扩容大小是原来的1.5倍</li><li>elementData  存放元素的<strong>数组</strong></li><li>size   实际元素个数</li><li>add（）添加元素</li></ul></li><li><p>add()源码：</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!    </span>elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// overflow-conscious code   </span><span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// overflow-conscious code    </span>     <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                  newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:    </span>       elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-Vector的使用"><a href="#3-2-4-Vector的使用" class="headerlink" title="3.2.4 Vector的使用"></a>3.2.4 Vector的使用</h4></li></ul><ol><li><p>添加元素</p></li><li><p>删除元素</p></li><li><p>遍历元素【<strong>重点</strong>】</p><ol><li><p>for循环、增强for、两种迭代器等都有</p></li><li><p>补充：使用枚举器</p><p> Enumeration en = vercot.elements(); </p></li></ol></li><li><p>判断</p></li><li><p>补充<br> firstElement()、lastElement()、Element()</p></li></ol><h4 id="3-2-5-LinkedList的使用-与前面的类似-："><a href="#3-2-5-LinkedList的使用-与前面的类似-：" class="headerlink" title="3.2.5 LinkedList的使用(与前面的类似)："></a>3.2.5 LinkedList的使用(与前面的<em>类似</em>)：</h4><ol><li>添加元素</li><li>删除元素</li><li>遍历元素【<strong>重点</strong>】<ol><li>for循环</li><li>增强for</li><li>两种迭代器<br> 3.1 迭代器Iterator<br> 3.2 列表迭代器ListIterator（也有正序、逆序两种）</li></ol></li><li>判断</li><li>查找</li></ol><h4 id="3-2-6-LinkedList源码分析"><a href="#3-2-6-LinkedList源码分析" class="headerlink" title="3.2.6 LinkedList源码分析"></a>3.2.6 LinkedList源码分析</h4><ul><li><p>源码分析：</p><ul><li>int size:集合的大小</li><li>Node first;链表的头节点</li><li>Node last;链表的尾节点</li></ul></li><li><p>add()源码：</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//add()public boolean add(E e) {&nbsp;&nbsp;&nbsp;     linkLast(e);&nbsp;&nbsp;&nbsp;     return true; }//尾部添加一个元素void linkLast(E e) {&nbsp;&nbsp;&nbsp;     final Node&lt;E&gt; l = last;&nbsp;&nbsp;&nbsp;    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);&nbsp;&nbsp;&nbsp;     last = newNode;&nbsp;&nbsp;&nbsp;     if (l == null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         first = newNode;&nbsp;&nbsp;&nbsp;     else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         l.next = newNode;&nbsp;&nbsp;&nbsp;     size++;&nbsp;&nbsp;&nbsp;    modCount++;}    //Node的源码    private static class Node&lt;E&gt; {&nbsp;&nbsp;&nbsp;         E item;&nbsp;&nbsp;&nbsp; Node&lt;E&gt; next;&nbsp;&nbsp;&nbsp;         Node&lt;E&gt; prev;&nbsp;&nbsp;&nbsp;         Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         this.item = element;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         this.next = next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         this.prev = prev;&nbsp;&nbsp;&nbsp; }          }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="4-泛型和工具类"><a href="#4-泛型和工具类" class="headerlink" title="4.泛型和工具类"></a>4.泛型和工具类</h2><h3 id="4-1-泛型概述"><a href="#4-1-泛型概述" class="headerlink" title="4.1 泛型概述"></a>4.1 泛型概述</h3><ul><li>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。</li><li>常见形式有泛型<strong>类</strong>、泛型<strong>接口</strong>、泛型<strong>方法</strong></li><li>语法：<ul><li>&lt;T,…&gt;  T称为类型占位符，表示一种<strong>引用类型</strong>。</li><li>T: Type类型；E：Element元素；K：Key键值；V：Value</li></ul></li><li>好处：<ul><li>(1)提高代码的重用性<ul><li>如泛型方法，方法的参数可以传递任何属性的值，以前实现的话需要用多态</li></ul></li><li>(2)防止类型转换异常,提高代码的安全性<ul><li>在泛型集合里面讲到</li></ul></li></ul></li></ul><h3 id="4-2-泛型的常用三种形式"><a href="#4-2-泛型的常用三种形式" class="headerlink" title="4.2 泛型的常用三种形式"></a>4.2 泛型的常用三种形式</h3><h4 id="4-2-1-泛型类"><a href="#4-2-1-泛型类" class="headerlink" title="4.2.1 泛型类"></a>4.2.1 泛型类</h4><ol><li><p>概念：</p><ul><li> 类语法：类名&lt;T&gt;</li><li>T是类型占位符,表示一种引用类型,如果编写多个使用逗号隔开</li><li>泛型类不能实例化；出错原因:此处由于不知道T的类型,有可能这个类型的构造方法是私有(private)的,无法构造</li><li>泛型作为方法的参数</li><li>泛型作为方法的返回值</li></ul></li></ol><ol start="2"><li><p>使用泛型创建对象：</p><ul><li>注意：<ul><li>1.泛型只能使用<strong>引用类型</strong>  </li><li>  2.不同泛型类型对象之间不能相互赋值</li></ul></li></ul></li></ol><h4 id="4-2-2-泛型接口"><a href="#4-2-2-泛型接口" class="headerlink" title="4.2.2 泛型接口"></a>4.2.2 泛型接口</h4><ol><li><p>概念：</p><ul><li>语法：接口名&lt;T&gt;</li><li> 注意：不能使用泛型来创建静态常量。Interface中的属性都是 Public Static final的。//T t; </li></ul></li><li><p>泛型接口实现类</p><ol><li><p>一种实现接口，在接口名字后面直接加上确定的类型<br><code>public class GenericInterfaceImpl implements GenericInterface&lt;String&gt;</code></p></li><li><p>另外一种实现接口，在类名后面加上<t>使得类成为泛型类，后面泛型接口的类型与泛型类的类型相同，这样使用更加普适。<br><code>public class GenericInterfaceImpl2&lt;T&gt; implements GenericInterface&lt;T&gt;</code></t></p></li></ol></li></ol><h4 id="4-2-3-泛型方法"><a href="#4-2-3-泛型方法" class="headerlink" title="4.2.3 泛型方法"></a>4.2.3 泛型方法</h4><ol><li><p>概念</p><ul><li>语法：&lt;T&gt; 返回值类型</li><li>示例： <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//泛型方法 </span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//注意：此T只能用在此方法范围内,超出范围不能使用    </span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是泛型方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p> 泛型方法的使用</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">GenericMethod genericMethod = new GenericMethod();//此处的类是普通类，泛型类型由泛型方法的参数决定genericMethod.show("中国加油");genericMethod.show(200);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="4-3-泛型集合"><a href="#4-3-泛型集合" class="headerlink" title="4.3 泛型集合"></a>4.3 泛型集合</h3><ul><li>概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致。</li><li>特点：<ul><li>编译时即可检查，而非运行时抛出异常。</li><li>访问时，不必类型转换（拆箱）。</li><li>不同泛型之间引用不能相互赋值，泛型不存在多态。</li></ul></li></ul><h2 id="5-Set接口与实现类"><a href="#5-Set接口与实现类" class="headerlink" title="5.Set接口与实现类"></a>5.Set接口与实现类</h2><h3 id="5-1-Set子接口"><a href="#5-1-Set子接口" class="headerlink" title="5.1 Set子接口"></a>5.1 Set子接口</h3><h4 id="5-1-1-Set基本概述"><a href="#5-1-1-Set基本概述" class="headerlink" title="5.1.1 Set基本概述"></a>5.1.1 Set基本概述</h4><ul><li>特点：无序、无下标、元素不可重复</li></ul><ul><li>方法：全部继承自 Collection中的方法。</li></ul><h4 id="5-1-2-Set接口使用"><a href="#5-1-2-Set接口使用" class="headerlink" title="5.1.2 Set接口使用"></a>5.1.2 Set接口使用</h4><ol><li><p>添加数据</p><ul><li>  添加的数据<strong>无序</strong></li><li>  添加的数据<strong>不重复</strong></li></ul></li><li><p>删除数据</p></li><li><p>遍历【重点】</p><ol><li>增强for</li><li>迭代器</li></ol></li><li><p>判断</p><ol><li>为空</li><li>包含</li></ol></li></ol><h3 id="5-2-Set实现类"><a href="#5-2-Set实现类" class="headerlink" title="5.2 Set实现类"></a>5.2 Set实现类</h3><h4 id="5-2-1-两种实现类"><a href="#5-2-1-两种实现类" class="headerlink" title="5.2.1 两种实现类"></a>5.2.1 两种实现类</h4><ol><li><p>HashSet【<strong>重点</strong>】</p><ul><li>基于 HashCode实现元素不重复。</li><li>当存入元素的哈希码相同时，会调用 equals进行确认，如结果为true，则拒绝后者存入。</li></ul></li><li><p>TreeSet：(使用二叉树实现)</p><ul><li>基于排列顺序实现元素不重复</li><li>实现了 Sortedset接口，对集合元素自动排序。</li><li>元素对象的类型必须实现 Comparable接口，指定排序规则。</li><li>通过 CompareTo方法确定是否为重复元素。</li></ul></li></ol><h4 id="5-2-2-HashSet的使用1"><a href="#5-2-2-HashSet的使用1" class="headerlink" title="5.2.2 HashSet的使用1"></a>5.2.2 HashSet的使用1</h4><ul><li>同Set的使用</li><li>存储结构：哈希表（数组+链表+{红黑树【JDK1.8之后】}）</li></ul><h4 id="5-2-3-HashSet的使用2"><a href="#5-2-3-HashSet的使用2" class="headerlink" title="5.2.3 HashSet的使用2"></a>5.2.3 HashSet的使用2</h4><ul><li><p>存储过程：</p><ul><li>(1) 根据 hashcode计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步</li><li>(2) 再执行equals方法，如果equals方法为true，则认为是重复，否则，形成链表。</li><li>(3) 总结：<ul><li> 先判断hashcode，如果相等(也就是位置相等)，那么判断equals相不相等(内容等不等)。</li><li> 此处需要重写<strong>hashcode</strong>()和<strong>equals</strong>()两个方法</li></ul></li></ul></li><li><p>补充：hashcode()编码</p><ul><li><p>编码中有prime = 31;<br>  （1）作用在31是一个质数，减少是散列冲突。</p><p>  （2）提高执行效率 。 31 * i = (i&lt;&lt;5) - i;</p></li></ul></li></ul><h4 id="5-2-4-TreeSet使用"><a href="#5-2-4-TreeSet使用" class="headerlink" title="5.2.4 TreeSet使用"></a>5.2.4 TreeSet使用</h4><ol><li>基本操作：<ol><li>添加</li><li>删除</li><li>遍历<ol><li>增强for</li><li>迭代器</li></ol></li><li>判断</li></ol></li></ol><ol start="2"><li><p>注意点：</p><ul><li><p>存储结构：红黑树</p></li><li><p> 要求：元素必须要实现 Compartle接口，compareTo()方法返回值为0，认为是重复元素</p></li><li><p><strong>方法一</strong>：compareTo()示例（实现接口的比较）：</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">  public int compareTo(Person o) {&nbsp;&nbsp;&nbsp;      int n1 =this.getName().compareTo(o.getName());&nbsp;&nbsp;&nbsp;      int n2 = this.age - o.getAge();&nbsp;&nbsp;&nbsp;      return n1 == 0 ? n2 : n1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="5-2-5-TreeSet使用2"><a href="#5-2-5-TreeSet使用2" class="headerlink" title="5.2.5 TreeSet使用2"></a>5.2.5 TreeSet使用2</h4><ul><li><p><strong>方法二</strong>：Comparator（定制比较）</p><ul><li>Comparator：实现定制比较（比较器）</li><li>Comparable：可比较的</li></ul></li><li><p>示例代码：</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">      TreeSet&lt;Person&gt; people = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() {&nbsp;&nbsp;&nbsp;       @Override&nbsp;&nbsp;&nbsp; //先按年龄比，再按姓名比&nbsp;&nbsp;&nbsp;      public int compare(Person o1, Person o2）      {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           int n1 = o1.getAge() - o2.getAge();          int n2 =o1.getName().compareTo(o2.getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          return n1 == 0? n2:n1;&nbsp;&nbsp;&nbsp;       }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="6-Map接口与实现类"><a href="#6-Map接口与实现类" class="headerlink" title="6.Map接口与实现类"></a>6.Map接口与实现类</h2><h3 id="6-1-Map集合概述"><a href="#6-1-Map集合概述" class="headerlink" title="6.1 Map集合概述"></a>6.1 Map集合概述</h3><p><img src="/2021/03/04/java-ji-he-kuang-jia/2Map%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0.jpg" alt="2Map集合概述"></p><ul><li>Map接口的特点：<ol><li>用于存储任意键值对（Key- Value）</li><li>键：无序、无下标、不允许重复（唯一）</li><li>值：无序、无下标、允许重复</li></ol></li></ul><h3 id="6-2-Map父接口"><a href="#6-2-Map父接口" class="headerlink" title="6.2 Map父接口"></a>6.2 Map父接口</h3><ul><li><p>特点：存储一对数据（Key- Value），无序、无下标，键不可重复，值可重复。</p></li><li><p>方法：</p><ul><li> V put(Kkey, v value)//将对象存入到集合中,关联键值.key重复则覆盖原值.</li><li>Object get( Object key)//根据键获取对应的值.</li><li>Set<k>//返回所有key </k></li><li>Collection<v> values0//返回包含所有值的 Collection集合. </v></li><li>Set&lt;Map. Entry&lt;K,V&gt;//键值匹配的Set集合.</li></ul></li></ul><h3 id="6-3-Map接口使用"><a href="#6-3-Map接口使用" class="headerlink" title="6.3 Map接口使用"></a>6.3 Map接口使用</h3><ol><li><p>特点:(1)存储键值对(2)键不能重复,值可以重复(3)无序</p></li><li><p>基本操作：</p><ol><li><p>添加元素</p><ul><li>当添加相同的key,而value不同时，会覆盖原先相同的key的value</li></ul></li><li><p>删除元素</p></li><li><p>遍历<br>  3.1使用keySet();返回的是所有key的Set集合</p> <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Set&lt;String&gt; keyset = map.keySet();for (String s : keyset) {&nbsp;&nbsp;&nbsp; System.out.println(s + "----" + map.get(s));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 3.2使用entrySet(); 返回的是et&lt;Map.Entry&lt;String,String&gt;&gt;,Entry&lt;String,String&gt;表示Map的键值对</p> <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();for (Map.Entry&lt;String, String&gt; entry : entries) {&nbsp;&nbsp;&nbsp; System.out.println(entry.getKey() + "--" + entry.getValue());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>判断</p></li></ol></li></ol><h3 id="6-4-Map集合的实现类"><a href="#6-4-Map集合的实现类" class="headerlink" title="6.4 Map集合的实现类"></a>6.4 Map集合的实现类</h3><h4 id="6-4-1-四种"><a href="#6-4-1-四种" class="headerlink" title="6.4.1 四种"></a>6.4.1 四种</h4><ol><li><p>HashMap【重点】:</p><ul><li>JDK1.2版本,线程不安全,运行效率快;允许用null作为key或是 value</li></ul></li><li><p>Hashtable [使用较少]:</p><ul><li>JDK1.0版本,线程安全,运行效率慢;不允许null作为key或是 value.</li></ul></li><li><p>Properties[使用<strong>较多</strong>]:</p><ul><li>Hashtable的<strong>子类</strong>,要求key和 value都是 String.通常用于配置文件的读取.</li></ul></li><li><p>TreeMap:</p><ul><li>实现了 SortedMap接口(是Map的子接口),可以对key自动排序.</li></ul></li></ol><h4 id="6-4-2-HashMap集合的使用"><a href="#6-4-2-HashMap集合的使用" class="headerlink" title="6.4.2 HashMap集合的使用"></a>6.4.2 HashMap集合的使用</h4><ul><li>基本概念：<ul><li>存储结构:哈希表(数组+链表+红黑树)</li><li>去重：使用key的hashcode和equals作为重复</li></ul></li></ul><ul><li>基本操作：与Map相同</li></ul><h4 id="6-4-3-HashMap源码分析"><a href="#6-4-3-HashMap源码分析" class="headerlink" title="6.4.3 HashMap源码分析"></a>6.4.3 HashMap源码分析</h4><ol><li>static final int DEFAULT INITIAL_ CAPACITY=1&lt;&lt;4;// hashMap初始容量大小</li><li>static fina1 int MAXIMUM CAPACITY=1&lt;&lt;39;// hashmark的数组最大容量</li><li>static fina1f1 oat dEfAULT loaD_ FACTOR=9.75f;//默认加载因子</li><li>static fina1 int TREEIFY THRESHOLD=8;//jdk1.8当链表长度大于8时,调整成红黑数</li><li>static final int UNTREEIFY THRESHOLD=6;//jdk1.8当链表长度小于6时,调整成链表</li><li>static fina1 int MIN TREEIFY CAPACITY=64://jdk1.8当链表长度大于8时,并且集合元素个数大于等于64时,调整成红黑数</li><li>transient node&lt;K,V&gt;[]tab1e;//哈希表中的数组</li><li>size;//元素个数</li></ol><ul><li><code>我的笔记</code>：<ul><li>当数组&gt;64，且有一个位置上的节点链表长度大于8时，那么HashMap此时转换为红黑树</li><li>当数组元素个数＜6时，此时红黑树转换为数组</li></ul></li></ul><hr><ul><li><p>构造方法：</p><ul><li><p>只有一句复制加载因子。</p><p>​    <code>public HashMap() {&nbsp;&nbsp;this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}</code></p></li><li><p>刚创建hashmap之后没有添加元素 table= null size=8  目的节省空间</p></li><li><p>当添加一个元素之后，数组空间变为16，当元素个数大于12（0.75的负载因子）时，扩容为原来2倍空间</p></li></ul></li><li><p>put方法：</p><p>  ​           <code>public V put(K key, V value) {&nbsp;&nbsp;return putVal(hash(key), key, value, false, true);}</code></p></li><li><p>总结：</p><ol><li>HashMap刚创建时,table是null,为了节省空间,当添加第一个元素是,tab1e容量调整为16</li><li>当元素个数大于阈值(16*.75=12)时,会进行扩容,扩容后大小为原来的2倍.日的是减少调整元素的个数.</li><li>jdk1.8当每个链表长度大于8,并且数组元素个数大于等于64时,会调整为红黑树,目的提高执行效率</li><li>jdk1.8当链表长度小于6时,调整成链表</li><li>jdk1.8以前,链表时头插入,jdk1.8以后时是尾插入</li></ol></li><li><p><strong>HashSet源码分析</strong>：内部其实用的就是HashMap</p></li></ul><h4 id="6-4-4-TreeMap的使用"><a href="#6-4-4-TreeMap的使用" class="headerlink" title="6.4.4 TreeMap的使用"></a>6.4.4 TreeMap的使用</h4><ul><li>基本操作，同HashMap</li><li>源码分析：<strong>TreeSet内部</strong>使用的是<strong>TreeMap</strong></li></ul><h2 id="7-Collections工具类"><a href="#7-Collections工具类" class="headerlink" title="7. Collections工具类"></a>7. Collections工具类</h2><h3 id="7-1概述"><a href="#7-1概述" class="headerlink" title="7.1概述"></a>7.1概述</h3><ul><li><p> 概念：集合工具类，定义了除了<strong>存取以外</strong>的集合常用方法 （类似的有<strong>Arrays工具类</strong>，对数组进行操作）</p></li><li><p>方法：</p><ul><li>public static void reverse(List&lt;?&gt;list)//反转集合中元素的顺序</li><li>public static void shuffle(List&lt;?&gt;list)//随机重置集合元素的顺序</li><li>public static void sort(List<t>list)//升序排序(元素类型必须实现Comparable接口)</t></li></ul></li></ul><h3 id="7-2-Collections工具类的使用"><a href="#7-2-Collections工具类的使用" class="headerlink" title="7.2 Collections工具类的使用"></a>7.2 Collections工具类的使用</h3><ol><li><p>sort()排序： <code>Collections.sort(list);</code></p></li><li><p>binarySearch二分查找：<code>Collections.binarySearch(list,13)</code></p></li><li><p>copy()复制：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将list转为dest</span><span class="token comment">//出错：Source does not fit in dest；需要适合dest的空间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>reverse()反转 <code>Collections.reverse(list);</code></p></li><li><p>shuffle()打乱 <code>Collections.shuffle(list);</code></p></li><li><p>补充：</p><p>6.1 list转数组</p><p>​    <code>Integer[] arr = (Integer[]) list.toArray(new Integer[0]);//我这个地方还需要强转一下</code></p><p>6.2  数组转成集合</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">List\&lt;String&gt; list1 = Arrays.asList(str);//此集合是受限集合，不可以删除和添加元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>6.3 基本类型数组转集合</p><p>​    <code>//把基本类型数组转为集合，需要修改为包装类型</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu_server2004配置</title>
      <link href="2021/02/14/ubuntu-server2004-pei-zhi/"/>
      <url>2021/02/14/ubuntu-server2004-pei-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>这篇文章思路有点乱，酌情观看（<strong>此文主要是配置ubuntu server2004，目的：部署hexo博客</strong>）</li></ul></blockquote><h2 id="1-更改镜像源"><a href="#1-更改镜像源" class="headerlink" title="1.更改镜像源"></a>1.更改镜像源</h2><p>a.修改sources.list文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>sudo vim /etc/apt/sources.list</code></p><p>b.更新</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>sudo apt-get update</code></p><blockquote><p>参考：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/finnhan/p/13709318.html">Ubuntu Server常用配置</a></p></blockquote><h2 id="2-连接ssh"><a href="#2-连接ssh" class="headerlink" title="2.连接ssh"></a>2.连接ssh</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>问题：</strong> packge “openssh-server” has no installation candidate:</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u><strong><em>主要原因：</em></strong> </u>出现这一系列问题是因为/etc/apt/sources.list文件已经被我删空了，<strong>恼死我</strong> 。</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssh连接不上，由于没有安装openssh-server.安装openssh-server不存在包，需要更新一下源<code>sudo apt-get update </code>,然后再安装openssh-server（<code>sudo apt-get install openssh-server</code>）此时则可成功安装，通过<code>ps -ef|grep ssh</code>查看ssh进程，如果看到了sshd那么成功。然后通过xshell就可以连接了。</p><ul><li>安装完成后手动开启服务：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>sudo /etc/init.d/ssh start</code></p><blockquote><p>参考：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zhuanlan.zhihu.com/p/129092645">‘openssh-server’ has no installation candidate</a></p></blockquote><h2 id="3-虚拟机网络设置"><a href="#3-虚拟机网络设置" class="headerlink" title="3.虚拟机网络设置"></a>3.虚拟机网络设置</h2><ul><li>连接网络时，使用桥接模式，然后ip地址就在同一个网段下了。（未设置之前是192.168.238.XXX）</li></ul><h2 id="4-ubuntu2004安装hexo博客"><a href="#4-ubuntu2004安装hexo博客" class="headerlink" title="4.ubuntu2004安装hexo博客"></a>4.ubuntu2004安装hexo博客</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先安装nodejs，可以安装，然后安装npm时，出现问题。<br><code>安装npm 报错npm : Depends: node-gyp (&gt;= 0.10.9) but it is not going to be installed</code>,参考2。此时安装弄好了npm 和 node,nodejs安装好一直查看不到版本号。 </p><blockquote><p>参考：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://wangjian8774.github.io/2021/01/09/wo-de-di-yi-pian-bo-ke-wen-zhang/">1.我的第一篇博客文章</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/weixin_42396621/article/details/95471084">2.Ubuntu 18.04安装npm 报错npm : Depends: node-gyp (&gt;= 0.10.9) but it is not going to be installed</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装centOS7及配置</title>
      <link href="2021/02/12/an-zhuang-centos7-ji-pei-zhi/"/>
      <url>2021/02/12/an-zhuang-centos7-ji-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装centOS7系统"><a href="#1-安装centOS7系统" class="headerlink" title="1.安装centOS7系统"></a>1.安装centOS7系统</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装的时候就正常安装，下载镜像源，按照步骤正常安装。此处我是选择最小安装，并且勾选了虽小安装的所有选项。</p><h2 id="2-配置centOS7系统"><a href="#2-配置centOS7系统" class="headerlink" title="2.配置centOS7系统"></a>2.配置centOS7系统</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①基础软件的安装</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）yum -y install net-tools</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）yum -y install vim</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）yum -y install wget</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>问题：</strong> 无法使用ifconfig命令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决方法:</strong> 使用<code>yum -y install net-tools</code> 命令来安装。此时又发现<strong>问题：</strong> yum命令不可用，<strong>解决方法：</strong> <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code> (此时的vim还没有安装，不可使用)，修改”ONBOOT”的值为”yes”，保存并退出。重启系统：<code>reboot</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此可以使用yum命令来安装相关软件</p><blockquote><p>参考:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/qq_34256296/article/details/81322243">1.CentOS7的安装及配置</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/duanlinxiao/p/11002741.html">2.解决centos-yum无法正常使用问题</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②配置静态IP（防止每次连接时ip地址动态变化）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用ifconfig查看IP地址，看是否有ip地址，如果有则跳过a。</p><p>a.分配IP地址：使用 <code>dhclient</code> (为虚拟机网络自动分配一个网络内可用的IP地址)，然后将此ip地址固定下来。</p><p>b.修改配置文件：<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code> :</p><p>&nbsp;&nbsp;&nbsp;&nbsp;修改以下：<br>将”BOOTPROTO”的值由”dhcp”修改为”static”;<br>将”ONBOOT”的值由”no”改为”yes”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;添加以下：</p><pre class="line-numbers language-配置文件" data-language="配置文件"><code class="language-配置文件">IPADDR=192.168.1.102NETMASK=255.255.255.0GATEWAY=192.168.1.1DNS1=119.29.29.29<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>保存并退出。重启网络：<code>systemctl restart network.service</code></p>]]></content>
      
      
      <categories>
          
          <category> centOS7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centOS7系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化hexo博客</title>
      <link href="2021/01/21/you-hua-hexo-bo-ke/"/>
      <url>2021/01/21/you-hua-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="1-picgo工具-github图床（系统：ubuntu1804）-此实践未成功，请勿仿照"><a href="#1-picgo工具-github图床（系统：ubuntu1804）-此实践未成功，请勿仿照" class="headerlink" title="1.picgo工具+github图床（系统：ubuntu1804）(此实践未成功，请勿仿照)"></a>1.picgo工具+github图床（系统：ubuntu1804）(<strong>此实践未成功，请勿仿照</strong>)</h2><p>①安装picgo<br><code>npm install picgo -g</code></p><p>②使用交互式命令自动生成picgo的配置文件<br><code>picgo set uploader</code><br><img src="https://github.com/wangjian8774/blog-picgo/blob/master/img/picgo-AutoConfig.jpg" alt="picgo-AutoConfig">  </p><pre class="line-numbers language-配置文件" data-language="配置文件"><code class="language-配置文件">{  "repo": "", // 仓库名，格式是username/reponame  "token": "", // github token  "path": "", // 自定义存储路径，比如img/  "customUrl": "", // 自定义域名，注意要加http://或者https://  "branch": "" // 分支名，默认是main}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在github上创建一个新的repository,然后配置github token，将具体信息配置入上面配置文件</p><p>③上传图片  </p><pre class="line-numbers language-none"><code class="language-none">方法：你安装的PicGo的路径 upload xxx.jpg  例如：/usr/local/bin/picgo upload handsome.jpg //需要当前目录下有xxx.jpg文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>简单方法：</strong> 使用图形化工具上传图片<br>下载来自：<a href="https://github.com/Molunerfinn/PicGo/releases">Molunerfinn/PicGo下载地址</a><br>我是用到的版本为PicGo-2.3.0-beta.4.AppImage（ubuntu1804）,直接下载后双击就可以打开,配置相应的GitHub图床即可使用</p><blockquote><p>主要参考：<a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/getting-started.html#%E4%B8%B4%E6%97%B6%E5%B0%9D%E9%B2%9C">快速上手</a><br>次要参考：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">听说你也想用PicGo</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/Molunerfinn/PicGo">Molunerfinn/PicGo开源项目</a><br>想法来源1：<a href="https://removeif.github.io/theme/github-page%E7%BD%91%E7%AB%99cdn%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F.html">github page网站cdn优化加速</a><br>想法来源2：<a href="https://removeif.github.io/theme/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0picgo%E5%B7%A5%E5%85%B7github%E5%9B%BE%E4%BC%A0%E4%BD%BF%E7%94%A8.html">博客图片上传picgo工具github图传使用摘要</a></p></blockquote><h2 id="2-我的图片上传方法-有用；上面那种方法搞到头秃也没能成功，这个方法真香"><a href="#2-我的图片上传方法-有用；上面那种方法搞到头秃也没能成功，这个方法真香" class="headerlink" title="2.我的图片上传方法(有用；上面那种方法搞到头秃也没能成功，这个方法真香)"></a>2.我的图片上传方法(有用；上面那种方法搞到头秃也没能成功，这个方法真香)</h2><blockquote><p>参考：<a href="https://wangjian8774.github.io/2021/01/19/blog-configuration-issues/">blog configuration issues.4</a></p></blockquote><p><img src="/2021/01/21/you-hua-hexo-bo-ke/photo-configuration.png" alt="示例图片"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu1804网络图标不见</title>
      <link href="2021/01/20/ubuntu1804-wang-luo-tu-biao-bu-jian/"/>
      <url>2021/01/20/ubuntu1804-wang-luo-tu-biao-bu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="网络图标找不到"><a href="#网络图标找不到" class="headerlink" title="网络图标找不到"></a>网络图标找不到</h2><p><strong>方法：</strong> 1、删除NetworkManager缓存文件<br>service NetworkManager stop<br>sudo rm /var/lib/NetworkManager/NetworkManager.state<br>service NetworkManager start</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、修改/etc/NetworkManager/NetworkManager.conf<br>managed=true</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、重启NetworkManager<br>sudo service network-manager restart</p><blockquote><p>参考：<a href="https://www.cnblogs.com/rainingday/p/13877304.html">Ubuntu18.04网络图标不见了，解决办法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu系统问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog configuration issues</title>
      <link href="2021/01/19/blog-configuration-issues/"/>
      <url>2021/01/19/blog-configuration-issues/</url>
      
        <content type="html"><![CDATA[<h2 id="1-busuanzi-problem"><a href="#1-busuanzi-problem" class="headerlink" title="1.busuanzi problem"></a>1.busuanzi problem</h2><p><strong>问题：</strong> 一直再找<a href="http://localhost:4000/">http://localhost:4000/</a> 时不蒜子统计数字不正确，改来改去就不知道问题在哪<br><strong>原因：</strong> 原来出在本地访问的问题，推到线上就正常了，被这东西搞了好几个小时，终于找到问题所在</p><blockquote><p>参考：</p><ul><li><a href="https://removeif.github.io/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html">不蒜子统计常见问题</a></li></ul></blockquote><h2 id="2-在配置文件中，每一个元素的冒号后面都要加一个空格"><a href="#2-在配置文件中，每一个元素的冒号后面都要加一个空格" class="headerlink" title="2.在配置文件中，每一个元素的冒号后面都要加一个空格"></a>2.在配置文件中，每一个元素的冒号后面都要加一个空格</h2><h2 id="3-配置个性化博客"><a href="#3-配置个性化博客" class="headerlink" title="3.配置个性化博客"></a>3.配置个性化博客</h2><blockquote><p>参考：</p><ul><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-21">超详细Hexo+Github博客搭建小白教程</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a> </li></ul></blockquote><h2 id="4-在博客中插入图片"><a href="#4-在博客中插入图片" class="headerlink" title="4.在博客中插入图片"></a>4.在博客中插入图片</h2><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_41907806/article/details/109064385">hexo博客中如何插入图片</a></li></ul></blockquote><h2 id="5-博客运行出错时，看清到底是那个文件出错，文件内找不出来的话，用vsCode进行两文件对比（重要）"><a href="#5-博客运行出错时，看清到底是那个文件出错，文件内找不出来的话，用vsCode进行两文件对比（重要）" class="headerlink" title="5.博客运行出错时，看清到底是那个文件出错，文件内找不出来的话，用vsCode进行两文件对比（重要）"></a>5.博客运行出错时，看清到底是那个文件出错，文件内找不出来的话，用vsCode进行两文件对比<strong>（重要）</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="2021/01/19/hello-world/"/>
      <url>2021/01/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="2021/01/09/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>2021/01/09/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来自<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.videocard.0">(Bilibili)手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p></blockquote><hr><h2 id="1-部署环境"><a href="#1-部署环境" class="headerlink" title="1.部署环境"></a>1.部署环境</h2><p>①安装nodejs<br><code>sudo apt-get install nodejs</code></p><p>②安装npm<br><code>sudo apt-get install npm</code></p><p>③安装cnpm<br><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p><p>④正式安装hexo<br><code>cnpm install -g hexo-cli</code></p><h2 id="2-初始化个人博客"><a href="#2-初始化个人博客" class="headerlink" title="2.初始化个人博客"></a>2.初始化个人博客</h2><p>①在/home/jian创建blog目录<br><code>mkdir blog</code></p><p>②初始化博客<br> <code>sudo hexo init</code><br>//<strong>问题：</strong>此处一直出现throw new TypeError(‘Console expects a writable stream instance’);<br>错误：是因为node的版本过低，要在10.0以上，更新方法如下：<br>a.先安装n模块<br><code>sudo npm install -g n</code><br>b.更新 node<br><code>sudo n latest</code></p><p>③启动博客<br><code>hexo s</code></p><h2 id="3-如何写博客"><a href="#3-如何写博客" class="headerlink" title="3.如何写博客"></a>3.如何写博客</h2><p>①创建博客<br><code>hexo n "我的第一篇博客文章"</code><br>②修改文章内容<br><code>vim 我的第一篇博客文章      //到相应目录下</code><br>③清理、生成</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">//先返回/blog目录hexo clean  //清理hexo g //生成hexo s//重新启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>问题：</strong>FATAL Port 4000 has been used. Try other port instead.</p><p><strong>解决方法：</strong>关掉终端，重新打开（原因：上次关闭hexo s 是用ctrl z，实际这个线程没关掉，4000端口被占用，下次关闭用ctrl c）</p><h2 id="4-如何把个人博客部署到远端"><a href="#4-如何把个人博客部署到远端" class="headerlink" title="4.如何把个人博客部署到远端"></a>4.如何把个人博客部署到远端</h2><p>①在github上创建新仓库</p><p>② 在blog目录下安装git部署插件<br><code>cnpm install --save hexo-deployer-git</code></p><p>③配置_config.yml </p><pre class="line-numbers language-text" data-language="text"><code class="language-text">-----# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git  branch: master-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>④部署到Github仓库里<br><code>hexo d</code></p><p>⑤访问这个地址可以查看博客<br><code>https://YourGithubName.github.io/  </code></p><h2 id="5-如何给个人博客换主题"><a href="#5-如何给个人博客换主题" class="headerlink" title="5.如何给个人博客换主题"></a>5.如何给个人博客换主题</h2><p>① 下载yilia主题到本地<br><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p><p>②#修改hexo根目录下的 _config.yml 文件<br> <code>theme: yilia</code></p><p>③重新部署到github</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo c//清理一下hexo g//生成        //hexo s //在本地可以预览hexo d//部署到远程Github仓库https://YourGithubName.github.io/  //查看博客<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
